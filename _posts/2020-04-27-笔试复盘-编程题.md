---
layout:     post
title:      笔试复盘-编程题
date:       2020-05-04
author:     CoCo
header-img: img/post-header.jpg
catalog: true
tags:
    - 笔试编程题
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 添加符号使等式成立
> 来源：招商银行信用卡中心－IT类实习生

**题目描述：**

给你一个数字的字符串，你可以在里面添加加号和减号，使得最终的运算结果等于ｋ．现在想知道有多少种满足要求的添加符号方案

**输入：**

第一行输入一个整数Ｔ，代表有Ｔ组测试数据

对于每一组测试数据，一行输入一个字符串ｓ和一个整数ｋ

$1 <= T <= 100,  1 <= len(s) <= 12,  1 <= k <= 10000$

**输出：**
对于每一组数据，输出一行，代表满足的方案数量为多少

**样例输入：**
```
2
21 1
12345 3
```
**样例输出：**
```
1
1
```
**说明：**

对于第一组，我们可以选择的是`２－１＝１`，故答案为１

第二组：我们选择是`１－２＋３－４＋５＝３`，只有这一种方案，故答案为１

**考场错误：**

尝试用DFS遍历所有表达式，再依次求出所有表达式的值，和ｋ进行比较
但是在DFS恢复现场的时候出错了，原因在于`pop`的次数不好把控

**正确解答：**

DFS（思路有点trick）：

每次搜索的下一轮搜索`idx`有多种情况可以选，取决于这一轮合并了几个字符：

以字符串`s='12345'`为例，从`idx=0`的位置开始搜索，若这一轮合并了１个字符（`'1'`），那么下一轮搜索的`idx`就是2，即下一轮从`'２'`开始搜索）；若这一轮合并了２个字符（`'12'`），那么下一轮搜索的`idx`就是2，即下一轮从`'3'`开始搜索

在确定了本轮合并的字符个数后，又要分为２种情况讨论：

①本轮合并的字符前的符号是`＋`　②本轮合并的字符前的符号是`－`

特别的，当本轮`idx=0`时，本轮合并的字符前的符号只能是`＋`，不能是`－`
```py
def dfs(idx, k):
    # idx: 当前的下标
    
    # 从当前idx开始到最后一个字符，需要凑出数字k
    
    global res
    if idx == n:
        if not k:
            res += 1
        return
    pre = 0
    for i in range(idx, n): 
        pre = pre * 10 + s[i]
        if idx:
            dfs(i + 1, k + pre)
        dfs(i + 1, k - pre)

res = 0
n = 6
k = 3
s = [1,1,1,1,1,1]
dfs(0, k)
print(res)　　
```


# 平行线段
> 来源：京东-春季实习生-算法

**题目描述：**

给出平面上的`2n`个点，你可以将这`2n`个点每两个匹配到一起得到`n`条线段。请你计算一种匹配方式，使得你得到的这`n`条线段，平行的线段对数最多

**输入：**

第一行包含一个整数`2n`  $2<=2n<=16$

接下来的`2n`行，每行包含两个整数`x,y`，表示一个点的坐标  $-1000 <= x, y <= 1000$

保证所有的点都不重合，并且没有三点共线

**输出：**

输出最多能有多少对线段平行

**样例输入：**
```
8
0 0
0 5 
2 2
2 7
3 -2
5 0
4 -2
8 2
```

**样例输出：**
```
6
```
**提示：**

这8个点可以组成4条两两平行的线段，所以最多可以有6对平行线段

**考场错误：**

一脸懵逼，理不清思路

# 完美对
> 来源：腾讯-机器学习-暑期实习

**题目描述：**

有`n`个物品，每个物品有`k`个属性，第`i`件物品的第`j`个属性用一个正整数表示记为$a_{i,j}$，两个不同的物品`i,j`被称为是“完美对”当且仅当$a_{i,1} + a_{j,1} = a_{i,2} + a_{j,2} = ··· = a_{i,k} + a_{j,k}$, 求完美对的个数

**输入：**

第一行两个数字`n,k`

接下来`n`行，第`i`行`k`    个数字表示$a_{i,1},a_{i,2},...,a_{i,k}$

$1 <= n <= 10^5, 2 <= k <= 10, 1 <= a_i <= 100$

**输出：**

一行一个数字表示答案

**样例输入：**
```
5 3
2 11 21
19 10 1
20 11 1
6 15 24
18 27 36
```
**样例输出：**
```
3
```
**考场错误：**

暴力求解，复杂度是 $O(n^2k)$，只AC 30%

**正确解答：**

将 $a_{i,1} + a_{j,1} = a_{i,2} + a_{j,2} = ··· = a_{i,k} + a_{j,k}$ 转化为 $a_{i,t} - a_{i,1} = -(a_{j,t} - a_{j,1})$, 其中$t = 2, 3, ... , k$，用字典存储每种情况的个数。需要注意的是，如果一个物品的所有属性都相等，不能把它和自己算为一个完美对。边读取数据，边累加结果，复杂度为 $O(nk)$
```py
from collections import defaultdict
def pair(n, k, a):
    t = [0 for i in range(k)]
    check = defaultdict(lambda: 0)
    res = 0
    for i in range(n):
        for j in range(1, k):
            a[i][j] -= a[i][0]
            t[j] = -a[i][j]
        # 如果一个物品的所有属性都相等，不能把它和自己算为一个完美对，因此接下来两行代码的顺序不能交换
        
        res += check[tuple(t[1:])]
        check[tuple(a[i][1:])] += 1
    return res

n, k = 5, 3
a = [[2, 11, 21], [19, 10, 1], [20, 11, 1], [6, 15, 24], [18, 27, 36]]
print(pair(n, k, a))
```


